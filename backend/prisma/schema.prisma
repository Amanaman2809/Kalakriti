generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  createdAt     DateTime       @default(now())
  password      String?
  phone         String         @unique
  role          Role           @default(USER)
  updatedAt     DateTime       @updatedAt
  isVerified    Boolean        @default(false)
  name          String
  oauthId       String?
  oauthProvider String?
  otp           String?
  otpExpiresAt  DateTime?
  addresses     Address[]
  cartItems     CartItem[]
  feedbacks     Feedback[]
  orders        Order[]
  payments      Payment[]
  refunds       Refund[]
  storeCredits  StoreCredit[]
  wishlist      WishlistItem[]
}

model Address {
  id         String   @id @default(uuid())
  street     String
  city       String
  state      String
  country    String
  postalCode String
  phone      String
  userId     String
  createdAt  DateTime @default(now())
  isDefault  Boolean  @default(false)
  updatedAt  DateTime @default(now()) @updatedAt
  user       User     @relation(fields: [userId], references: [id])
  orders     Order[]  @relation("OrderAddress")

  @@index([userId])
  @@index([isDefault])
  @@index([userId, isDefault])
}

model Product {
  id            String         @id @default(uuid())
  name          String
  description   String?
  price         Int
  stock         Int            @default(0)
  tags          String[]
  images        String[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  categoryId    String
  discountPct   Int?           @db.SmallInt
  cartItems     CartItem[]
  feedbacks     Feedback[]
  orderItems    OrderItem[]
  category      Category       @relation(fields: [categoryId], references: [id])
  averageRating Float          @default(0.0)
  numReviews    Int            @default(0)
  wishlistItems WishlistItem[]
}

model Category {
  id       String    @id @default(uuid())
  name     String    @unique
  image    String?
  products Product[]
}

model WishlistItem {
  id        String  @id @default(uuid())
  userId    String
  productId String
  product   Product @relation(fields: [productId], references: [id])
  user      User    @relation(fields: [userId], references: [id])

  @@unique([userId, productId])
}

model Feedback {
  id        String   @id @default(uuid())
  rating    Int      @db.SmallInt
  comment   String?
  userId    String
  productId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  product   Product  @relation(fields: [productId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, productId])
}

/// *
///  * Ledger-style StoreCredit
///  * amount: positive for credit, negative for debit entries
///  * remaining is optional; we will prefer to compute remaining via relation
model StoreCredit {
  id           String        @id @default(uuid())
  userId       String
  amount       Int
  reason       String?
  createdAt    DateTime      @default(now())
  expiresAt    DateTime?
  orderCredits OrderCredit[]
  user         User          @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expiresAt])
}

/// *
///  * Order - explicit amounts:
///  * grossAmount = sum(items.price*qty)  (paise)
///  * shippingAmount = shipping (paise)
///  * taxAmount = tax (paise)
///  * creditsApplied = total credits consumed for this order (paise)
///  * netAmount = grossAmount + shippingAmount + taxAmount - creditsApplied
model Order {
  id                 String        @id @default(uuid())
  userId             String
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  paymentMode        PaymentMode
  paymentStatus      PaymentStatus
  status             OrderStatus
  addressId          String
  carrierName        String?
  deliveredAt        DateTime?
  estimatedDelivery  DateTime?
  shippedAt          DateTime?
  statusUpdatedAt    DateTime      @default(now())
  trackingNumber     String?
  cancellationReason String?
  cancelledAt        DateTime?
  creditsApplied     Int
  grossAmount        Int
  netAmount          Int
  shippingAmount     Int
  taxAmount          Int
  address            Address       @relation("OrderAddress", fields: [addressId], references: [id])
  user               User          @relation(fields: [userId], references: [id])
  orderCredits       OrderCredit[]
  items              OrderItem[]
  payments           Payment[]
  refunds            Refund[]

  @@index([userId])
  @@index([createdAt])
}

/// *
///  * Order item stores price (paise) at time of order
model OrderItem {
  id              String  @id @default(uuid())
  orderId         String
  productId       String
  quantity        Int
  price           Int
  discountApplied Int?
  order           Order   @relation(fields: [orderId], references: [id])
  product         Product @relation(fields: [productId], references: [id])
}

/// *
///  * Mapping which StoreCredit rows funded which Order (partial allowed).
///  * amount = how much taken from that StoreCredit (positive number).
///  * If a StoreCredit row had amount=500 and orderCredit.amount=200, remaining = 300.
model OrderCredit {
  id            String      @id @default(uuid())
  orderId       String
  storeCreditId String
  amount        Int
  createdAt     DateTime    @default(now())
  order         Order       @relation(fields: [orderId], references: [id])
  storeCredit   StoreCredit @relation(fields: [storeCreditId], references: [id])

  @@index([orderId])
  @@index([storeCreditId])
}

/// *
///  * Payment record for gateway interactions (Razorpay/Stripe etc.)
///  * provider = "razorpay" or "stripe"
///  * providerPaymentId = external id (for lookups)
model Payment {
  id                String        @id @default(uuid())
  orderId           String
  userId            String
  provider          String?
  providerPaymentId String?
  amount            Int
  status            PaymentStatus
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  meta              Json?
  order             Order         @relation(fields: [orderId], references: [id])
  user              User          @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
}

/// *
///  * Refund audit record
///  * method = GATEWAY or STORE_CREDIT
model Refund {
  id        String       @id @default(uuid())
  orderId   String
  userId    String
  method    RefundMethod
  amount    Int
  reason    String?
  createdAt DateTime     @default(now())
  meta      Json?
  order     Order        @relation(fields: [orderId], references: [id])
  user      User         @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
}

/// *
///  * CartItem as before
model CartItem {
  id        String  @id @default(uuid())
  userId    String
  productId String
  quantity  Int
  product   Product @relation(fields: [productId], references: [id])
  user      User    @relation(fields: [userId], references: [id])

  @@unique([userId, productId])
}

enum Role {
  USER
  ADMIN
}

enum PaymentMode {
  COD
  ONLINE
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum OrderStatus {
  PLACED
  SHIPPED
  DELIVERED
  PENDING
  CANCELLED
}

enum RefundMethod {
  GATEWAY
  STORE_CREDIT
}
